# Ctrl+C

Кроссплатформенный код (C++11) для обработки события Ctrl+C в пользовательских функциях.
Поддерживаются Windows, Linux и Mac OS X.

## Использование

Для обработки события/сигнала Ctrl+C следует вызвать функцию:
```cpp
unsigned int CtrlCLibrary::SetCtrlCHandler(std::function<bool(enum CtrlCLibrary::CtrlSignal)> handler);
```
где handler - пользовательская функция;

**Возвращаемое значение**:
Возвращается идентификатор добавленного обработчика. В случае ошибки возвращается CtrlCLibrary::kErrorID.

Для удаления обработчика следует вызвать функцию:
```cpp
void CtrlCLibrary::ResetCtrlCHandler(unsigned int id);
```
где id - идентификатор обработчика, возвращённый функцией CtrlCLibrary::SetCtrlCHandler.

### Установка

Скопируйте файлы с кодом (src/ctrl-c.h, src/ctrl-c.cpp) в свой проект.

## Пример использования

Файл test/main.cpp показывает использование обработчика Ctrl+C.
Скомпилируйте  этот код своим любимыми компилятором.

## Автор

**Евгений Кислов** - [evgenykislov.com](https://evgenykislov.com), [github/evgenykislov](https://github.com/evgenykislov)

## Лицензия

Проект лицензирован под MIT License. Подробнее см. файл [LICENSE](LICENSE)

## Примечания

Допускается добавлять несколько обработчиков события Cntl+C. Все обработчики будут вызываны в обратном порядке (LIFO): первый добавленный обработчик будет вызван последним.
Каждый обработчик должен вернуть значение bool:
* *true* - остановить обработку и не вызывать последующие обработчики;
* *false* - продолжить обработку сигнала другими (следующими в очереди) обработчиками (дополнительно, см. примечания для Windows ниже).

Функции установки и сброса обработчика, а также сам обработчик являются потокобезопасными.  *Внимание*: Не следует удалять обработчик события в самом обработчике события - это может вызвать блокироку (deadlock).

#### Ошибки
Добавление нового обработчика может вернуть ошибку (kErrorID) в случае недостатка памяти или системной ошибки.

#### Исключения
Код обрабатывает свои ошибки, а также ошибки выделения памяти в вызове SetCtrlCHandler. В этом случае возвращается идентификатор (kErrorID).
Другие исключения не обрабатываются, следует их ловить (и обрабатывать) в своём коде.

#### Примечания для Linux и Mac OS X
Установка любого обработчика приведёт к тому, что предыдущий обработчик перестанет работать. Если первое добавление обработчика возвратит ошибку, то предыдущий обработчик также перестанет работать - ОС будет вызывать обработчик по-умолчанию.
Удаление всех обработчиков приведёт к установке обработчика Ctrl+C по-умолчанию.

#### Примечания для Windows
Если все обработчики вернут **false**, то будет вызван предыдущий обработчик. Это может быть обработчик самой ОС и в этом случае процесс может быть закрыт.
